---
- name: Integration tests for volume lifecycle against mock OpenStack
  hosts: localhost
  gather_facts: false
  vars:
    go_server_path: "{{ playbook_dir ~ '/fake/openstack/srv.go' }}"
    server_pid_file: /tmp/fake_os_server.pid
    fake_os_url: "http://127.0.0.1:5000"
    cloud_config:
      auth:
        auth_url: "http://127.0.0.1:5000/v3"
        username: "demo-user"
        password: "password"
        project_name: "demo"
        project_id: "demo-id"
        user_domain_name: "default"
        project_domain_name: "default"
        region_name: "RegionOne"
  tasks:
    # SETUP FOR FAKE SERVER
    - name: Setup fake OpenStack server
      tags: setup
      block:
        - name: Start fake OpenStack server asynchronously
          ansible.builtin.command: go run "{{ go_server_path }}"
          args:
            creates: "{{ server_pid_file }}"
          async: 30
          poll: 0
          register: fake_server_job
          changed_when: false

        - name: Check command
          ansible.builtin.async_status:
            jid: "{{ fake_server_job.ansible_job_id }}"
          register: result

        - name: Debug command
          ansible.builtin.debug:
            var: result.stdout

        - name: Wait for the server URL file to be created
          ansible.builtin.wait_for:
            path: "{{ server_pid_file }}"
            state: present
            timeout: 10

        - name: Read the server PID from the file
          ansible.builtin.slurp:
            src: "{{ server_pid_file }}"
          register: fake_os_pid_b64

        - name: Set the server PID fact
          ansible.builtin.set_fact:
            fake_os_pid: "{{ fake_os_pid_b64['content'] | b64decode }}"

        # TEST01: Compare detailed vs non-detailed volume list endpoints
        - name: TEST01 - Get non-detailed volume list
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: volumes_basic

        - name: Get detailed volume list
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes/detail"
            method: GET
            return_content: true
          register: volumes_detailed

        - name: "ASSERT: Both endpoints return volume data"
          ansible.builtin.assert:
            that:
              - "volumes_basic is succeeded"
              - "volumes_detailed is succeeded"
              - "((volumes_basic.content | from_json).volumes | length) > 0"
              - "((volumes_detailed.content | from_json).volumes | length) > 0"

        # TEST02: Filter volumes by name using query parameters
        - name: Create volumes with specific names for filtering
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"{{ item.name }}","size":{{ item.size }}}}'
            status_code: 202
          loop:
            - { name: "filter-test-alpha", size: 5 }
            - { name: "filter-test-beta", size: 10 }
            - { name: "other-name", size: 15 }
          register: filter_vols

        - name: Wait for volumes to become available
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes/{{ (item.content | from_json).volume.id }}"
            method: GET
            return_content: true
          register: filter_vol_status
          until: (filter_vol_status.content | from_json).volume.status == 'available'
          retries: 10
          delay: 1
          loop: "{{ filter_vols.results }}"

        - name: TEST02 - List volumes filtered by name
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes?name=filter-test-alpha"
            method: GET
            return_content: true
          register: filtered_by_name

        - name: "ASSERT: Name filter returns only matching volume"
          ansible.builtin.assert:
            that:
              - "filtered_by_name is succeeded"
              - "((filtered_by_name.content | from_json).volumes | length) == 1"
              - "((filtered_by_name.content | from_json).volumes[0].name) == 'filter-test-alpha'"

        # TEST03: Filter volumes by status using query parameters
        - name: TEST03 - List volumes filtered by status
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes?status=available"
            method: GET
            return_content: true
          register: filtered_by_status

        - name: "ASSERT: Status filter returns only available volumes"
          ansible.builtin.assert:
            that:
              - "filtered_by_status is succeeded"
              - "((filtered_by_status.content | from_json).volumes | length) > 0"
              - >-
                ((filtered_by_status.content | from_json).volumes |
                selectattr('status', 'equalto', 'available') | list | length) ==
                ((filtered_by_status.content | from_json).volumes | length)

          # TEST04: Filter volumes by metadata using query parameters
        - name: Create volumes with metadata
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "metadata-test-vol"
                size: 5
                metadata:
                  osm: "true"
                  changeID: "cbt-12345"
            status_code: 202
          register: metadata_vol

        - name: Wait for metadata volume to become available
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes/{{ (metadata_vol.content | from_json).volume.id }}"
            method: GET
            return_content: true
          register: metadata_vol_status
          until: (metadata_vol_status.content | from_json).volume.status == 'available'
          retries: 10
          delay: 1

        - name: TEST04 - List volumes filtered by metadata
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes?metadata[osm]=true"
            method: GET
            return_content: true
          register: filtered_by_metadata

        - name: "ASSERT: Metadata filter returns matching volumes"
          ansible.builtin.assert:
            that:
              - "filtered_by_metadata is succeeded"
              - "((filtered_by_metadata.content | from_json).volumes | length) >= 1"
              - >-
                ((filtered_by_metadata.content | from_json).volumes |
                selectattr('id', 'equalto', (metadata_vol.content | from_json).volume.id) |
                list | length) == 1


        # TEST05: List available flavors
        - name: TEST05 - List flavors (detailed)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/flavors/detail"
            method: GET
            return_content: true
          register: flavors_list

        - name: "ASSERT: Flavors endpoint returns data"
          ansible.builtin.assert:
            that:
              - "flavors_list is succeeded"
              - "((flavors_list.content | from_json).flavors | length) > 0"
              - "((flavors_list.content | from_json).flavors | selectattr('id', 'defined') | list | length) > 0"

        # TEST06: Authenticate and validate token format
        - name: TEST06 - Request authentication token
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/auth/tokens"
            method: POST
            body_format: json
            return_content: true
            body:
              auth:
                identity:
                  methods: ["password"]
                  password:
                    user:
                      name: "demo-user"
                      password: "password"
                      domain:
                        name: "default"
                scope:
                  project:
                    name: "demo"
                    domain:
                      name: "default"
            status_code: 201
          register: auth_token_test

        - name: "ASSERT: Token authentication successful"
          ansible.builtin.assert:
            that:
              - "auth_token_test is succeeded"
              - "auth_token_test.x_subject_token is defined"
              - "((auth_token_test.content | from_json).token.catalog | length) > 0"

        # TEST07: Various malformed JSON request formats
        - name: TEST07 - Send completely invalid JSON
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body: "this is not json at all"
            status_code: 400
          register: malformed_not_json
          failed_when: false

        - name: Send JSON with wrong structure
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"wrong_key":"value"}'
            status_code: 400
          register: malformed_wrong_structure
          failed_when: false

        - name: Send empty JSON
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: "{}"
            status_code: 400
          register: malformed_empty
          failed_when: false

        - name: "ASSERT: Malformed requests rejected (mock has limited validation)"
          ansible.builtin.assert:
            that:
              - "malformed_not_json.status == 400"
              - "malformed_wrong_structure.status in [400, 202]"
              - "malformed_empty.status in [400, 202]"
            msg: "Mock accepts some invalid JSON - real OpenStack would return 400"

      always:
        - name: Stop fake OpenStack server
          tags: cleanup
          ansible.builtin.command: "kill {{ fake_os_pid }}"
          changed_when: false
          failed_when: false

        - name: Remove PID file
          tags: cleanup
          ansible.builtin.file:
            path: "{{ server_pid_file }}"
            state: absent
          failed_when: false

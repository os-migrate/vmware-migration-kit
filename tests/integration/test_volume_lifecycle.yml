---
- name: Integration tests for volume lifecycle against mock OpenStack
  hosts: localhost
  gather_facts: false
  vars:
    go_server_path: "{{ playbook_dir ~ '/fake/openstack/srv.go' }}"
    server_pid_file: /tmp/fake_os_server.pid
    fake_os_url: "http://127.0.0.1:5000"
    cloud_config:
      auth:
        auth_url: "http://127.0.0.1:5000/v3"
        username: "demo-user"
        password: "password"
        project_name: "demo"
        project_id: "demo-id"
        user_domain_name: "default"
        project_domain_name: "default"
        region_name: "RegionOne"
  tasks:
    # SETUP FOR FAKE SERVER
    - name: Setup fake OpenStack server
      tags: setup
      block:
        - name: Start fake OpenStack server asynchronously
          ansible.builtin.command: go run "{{ go_server_path }}"
          args:
            creates: "{{ server_pid_file }}"
          async: 30
          poll: 0
          register: fake_server_job
          changed_when: false

        - name: Check command
          ansible.builtin.async_status:
            jid: "{{ fake_server_job.ansible_job_id }}"
          register: result

        - name: Debug command
          ansible.builtin.debug:
            var: result.stdout

        - name: Wait for the server URL file to be created
          ansible.builtin.wait_for:
            path: "{{ server_pid_file }}"
            state: present
            timeout: 10

        - name: Read the server PID from the file
          ansible.builtin.slurp:
            src: "{{ server_pid_file }}"
          register: fake_os_pid_b64

        - name: Set the server PID fact
          ansible.builtin.set_fact:
            fake_os_pid: "{{ fake_os_pid_b64['content'] | b64decode }}"

        # TEST02: Attach volume to server and verify status change
        - name: Create test server for attachment
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "test-server-02"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: test_server_02

        - name: Create volume for attachment test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "test-volume-02"
                size: 5
            status_code: 202
          register: test_volume_02

        - name: TEST02 - Attach volume to server (status in-use)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (test_server_02.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (test_volume_02.content | from_json).volume.id }}"
            status_code: 200
          register: result_attach

        - name: Get volumes list to verify status change
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: volumes_after_attach

        - name: "ASSERT: Volume status changed to in-use"
          ansible.builtin.assert:
            that:
              - "(result_attach.content | from_json).volumeAttachment is defined"
              - >-
                (result_attach.content | from_json).volumeAttachment.volumeId ==
                (test_volume_02.content | from_json).volume.id
              - >-
                ((volumes_after_attach.content | from_json).volumes |
                selectattr('id', 'equalto', (test_volume_02.content | from_json).volume.id) |
                first).status == 'in-use'
        - name: Create multiple test volumes
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"name":"{{ item.name }}","size":{{ item.size }}}}'
            status_code: 202
          loop:
            - { name: "test-vol-list-1", size: 5 }
            - { name: "test-vol-list-2", size: 10 }
            - { name: "test-vol-list-3", size: 15 }
          register: created_volumes

        - name: TEST03 - List volumes (multiple volumes)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: result_list_volumes

        - name: "ASSERT: All volumes are in the list"
          ansible.builtin.assert:
            that:
              - "(result_list_volumes.content | from_json).volumes is defined"
              - "((result_list_volumes.content | from_json).volumes | length) >= 3"
              - "'test-vol-list-1' in ((result_list_volumes.content | from_json).volumes | map(attribute='name') | list)"
              - "'test-vol-list-2' in ((result_list_volumes.content | from_json).volumes | map(attribute='name') | list)"
              - "'test-vol-list-3' in ((result_list_volumes.content | from_json).volumes | map(attribute='name') | list)"

        # TEST04: List volume attachments per server
        - name: Create server for attachment list test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "test-server-04"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: test_server_04

        - name: Create and attach volume
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "test-volume-04"
                size: 5
            status_code: 202
          register: test_volume_04

        - name: Attach volume to server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (test_server_04.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (test_volume_04.content | from_json).volume.id }}"
            status_code: 200
          register: attached_04

        - name: TEST04 - List volume attachments for server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (test_server_04.content | from_json).server.id }}/os-volume_attachments"
            method: GET
            return_content: true
          register: result_list_attachments

        - name: "ASSERT: Attachment appears in list"
          ansible.builtin.assert:
            that:
              - "(result_list_attachments.content | from_json).volumeAttachments is defined"
              - "((result_list_attachments.content | from_json).volumeAttachments | length) > 0"
              - >-
                ((result_list_attachments.content | from_json).volumeAttachments |
                selectattr('volumeId', 'equalto', (test_volume_04.content | from_json).volume.id) |
                list) | length == 1

        # TEST05: Attach volume using instance name lookup
        - name: Create named server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "conversion-host-test"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: named_server

        - name: Create volume for name lookup test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "test-volume-05"
                size: 5
            status_code: 202
          register: volume_05

        - name: Lookup server by name
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: GET
            return_content: true
          register: servers_list

        - name: Find server ID by name
          ansible.builtin.set_fact:
            found_server_id: "{{ ((servers_list.content | from_json).servers | selectattr('name', 'equalto', 'conversion-host-test') | first).id }}"

        - name: TEST05 - Attach volume using looked-up server ID
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ found_server_id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (volume_05.content | from_json).volume.id }}"
            status_code: 200
          register: result_attach_by_name

        - name: "ASSERT: Volume attached using name lookup"
          ansible.builtin.assert:
            that:
              - "result_attach_by_name is succeeded"
              - "(result_attach_by_name.content | from_json).volumeAttachment is defined"
              - "(result_attach_by_name.content | from_json).volumeAttachment.serverId == found_server_id"

        - name: TEST06 - Validate service catalog completeness
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/auth/tokens"
            method: POST
            body_format: json
            return_content: true
            body:
              auth:
                identity:
                  methods: ["password"]
                  password:
                    user:
                      name: "{{ cloud_config.auth.username }}"
                      domain: { name: "default" }
                      password: "{{ cloud_config.auth.password }}"
                scope:
                  project:
                    name: "{{ cloud_config.auth.project_name }}"
                    domain: { name: "default" }
            status_code: 201
          register: auth_response

        - name: Extract catalog from response
          ansible.builtin.set_fact:
            service_catalog: "{{ (auth_response.content | from_json).token.catalog }}"

        - name: "ASSERT: All required services in catalog"
          ansible.builtin.assert:
            that:
              - "service_catalog | selectattr('type', 'equalto', 'identity') | list | length > 0"
              - "service_catalog | selectattr('type', 'equalto', 'compute') | list | length > 0"
              - "service_catalog | selectattr('type', 'equalto', 'volumev3') | list | length > 0"
              - "service_catalog | selectattr('type', 'equalto', 'network') | list | length > 0"
              - "service_catalog | selectattr('type', 'equalto', 'image') | list | length > 0"
            msg: "Service catalog missing required services (Keystone, Nova, Cinder, Neutron, Glance)"

        # TEST07: Network + Server workflow
        - name: Create network
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/networks"
            method: POST
            body_format: json
            return_content: true
            body:
              network:
                name: "test-network-07"
            status_code: 201
          register: created_network

        - name: TEST07 - Create server with network (cross-service)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "test-server-07"
                flavorRef: "1"
                imageRef: "img-1"
                networks:
                  - uuid: "{{ (created_network.content | from_json).network.id }}"
            status_code: 202
          register: result_server_with_network

        - name: "ASSERT: Server has correct network assignment"
          ansible.builtin.assert:
            that:
              - "result_server_with_network is succeeded"
              - "((result_server_with_network.content | from_json).server.addresses | length) > 0"

        # TEST08: Port + Server with custom network config
        - name: Create SRIOV port
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: POST
            body_format: json
            return_content: true
            body:
              port:
                network_id: "net-1"
                binding:vnic_type: "direct"
            status_code: 201
          register: created_port

        - name: TEST08 - Create server with SRIOV port
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "test-server-08"
                flavorRef: "1"
                imageRef: "img-1"
                networks:
                  - port: "{{ (created_port.content | from_json).port.id }}"
            status_code: 202
          register: result_sriov_server

        - name: "ASSERT: Server created with SRIOV port"
          ansible.builtin.assert:
            that:
              - "result_sriov_server is succeeded"
              - "((created_port.content | from_json).port['binding:vnic_type']) == 'direct'"
              - "((created_port.content | from_json).port['binding:vif_details']) is defined"

        # TEST09: Concurrent volume creation
        - name: TEST09 - Create 5 volumes in parallel
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"{{ item.name }}","size":{{ item.size }}}}'
            status_code: 202
          loop:
            - { name: "concurrent-vol-1", size: 5 }
            - { name: "concurrent-vol-2", size: 5 }
            - { name: "concurrent-vol-3", size: 5 }
            - { name: "concurrent-vol-4", size: 5 }
            - { name: "concurrent-vol-5", size: 5 }
          async: 30
          poll: 0
          register: async_volumes

        - name: Wait for all volume creations
          ansible.builtin.async_status:
            jid: "{{ item.ansible_job_id }}"
          loop: "{{ async_volumes.results }}"
          register: volume_results
          until: volume_results.finished
          retries: 10
          delay: 1

        - name: "ASSERT: All concurrent volumes created successfully"
          ansible.builtin.assert:
            that:
              - "item is succeeded"
              - "(item.content | from_json).volume.id is defined"
          loop: "{{ volume_results.results }}"

        # TEST10: Full network stack creation
        - name: Create network for full stack
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/networks"
            method: POST
            body_format: json
            return_content: true
            body:
              network:
                name: "test-network-10"
            status_code: 201
          register: network_10

        - name: Create subnet
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/subnets"
            method: POST
            body_format: json
            body:
              subnet:
                network_id: "{{ (network_10.content | from_json).network.id }}"
                cidr: "192.168.10.0/24"
                ip_version: 4
            status_code: 201
          register: subnet_10

        - name: Create port
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: POST
            body_format: json
            return_content: true
            body:
              port:
                network_id: "{{ (network_10.content | from_json).network.id }}"
            status_code: 201
          register: port_10

        - name: TEST10 - Create server with full network stack
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "test-server-10"
                flavorRef: "1"
                imageRef: "img-1"
                networks:
                  - port: "{{ (port_10.content | from_json).port.id }}"
            status_code: 202
          register: result_full_stack

        - name: "ASSERT: Complete workflow succeeded"
          ansible.builtin.assert:
            that:
              - "network_10 is succeeded"
              - "subnet_10 is succeeded"
              - "port_10 is succeeded"
              - "result_full_stack is succeeded"

        # TEST11: Error propagation testing
        - name: TEST11 - Module error handling (invalid JSON)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body: "invalid-json-string"
            headers:
              Content-Type: "application/json"
            status_code: [200, 201, 202, 400]
          register: result_bad_json

        - name: "ASSERT: Invalid JSON returns 400"
          ansible.builtin.assert:
            that:
              - "result_bad_json.status == 400"

        # TEST12: Idempotency validation
        - name: Create volume first time
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "idempotent-test"
                size: 5
            status_code: 202
          register: first_create

        - name: TEST12 - Create same volume second time
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body:
              volume:
                name: "idempotent-test"
                size: 5
            status_code: 202
          register: second_create

        - name: "ASSERT: Mock allows duplicate creation (module should handle)"
          ansible.builtin.assert:
            that:
              - "first_create is succeeded"
              - "second_create is succeeded"
              - "(first_create.content | from_json).volume.id != (second_create.content | from_json).volume.id"
            msg: "Mock doesn't prevent duplicates - real module should detect and return changed=false"

            # TEST13: Volume creation with edge case sizes (1GB, 1000GB)
        - name: TEST13 - Create volume with minimum size (1GB)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"edge-case-1gb","size":1}}'
            status_code: 202
          register: vol_1gb

        - name: Create volume with large size (1000GB)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"edge-case-1000gb","size":1000}}'
            status_code: 202
          register: vol_1000gb

        - name: "ASSERT: Edge case volumes created successfully"
          ansible.builtin.assert:
            that:
              - "vol_1gb is succeeded"
              - "vol_1000gb is succeeded"
              - "((vol_1gb.content | from_json).volume.size) == 1"
              - "((vol_1000gb.content | from_json).volume.size) == 1000"

        # TEST14: Volume creation with special characters in name
        - name: TEST14 - Create volumes with special characters
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"{{ item.name }}","size":5}}'
            status_code: 202
          loop:
            - { name: "volume-with-dashes" }
            - { name: "volume_with_underscores" }
            - { name: "volume.with.dots" }
            - { name: "volume@with#symbols" }
          register: special_char_volumes

        - name: "ASSERT: Special character volumes created"
          ansible.builtin.assert:
            that:
              - "item is succeeded"
              - "(item.content | from_json).volume.name == item.item.name"
          loop: "{{ special_char_volumes.results }}"

        # TEST15: Volume creation with missing required fields
        - name: TEST15 - Create volume with missing name field
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"size":5}}'
            status_code: [400, 202]
          register: missing_name
          failed_when: false

        - name: Create volume with missing size field
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"name":"missing-size"}}'
            status_code: [400, 202]
          register: missing_size
          failed_when: false

        - name: "ASSERT: Missing fields handled (mock may allow, real API rejects)"
          ansible.builtin.assert:
            that:
              - "missing_name.status in [400, 202]"
              - "missing_size.status in [400, 202]"
            msg: "Mock server behavior documented - real OpenStack would return 400"

        # TEST16: Volume creation with invalid size types
        - name: TEST16 - Create volume with string size
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"name":"invalid-string-size","size":"not-a-number"}}'
            status_code: 400
          register: invalid_string_size
          failed_when: false

        - name: Create volume with negative size
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"name":"invalid-negative","size":-10}}'
            status_code: [400, 202]
          register: invalid_negative
          failed_when: false

        - name: Create volume with null size
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"volume":{"name":"invalid-null","size":null}}'
            status_code: [400, 202]
          register: invalid_null
          failed_when: false

        - name: "ASSERT: Invalid size types rejected or handled"
          ansible.builtin.assert:
            that:
              - "invalid_string_size.status == 400"
              - "invalid_negative.status in [400, 202]"
              - "invalid_null.status in [400, 202]"

        # TEST17: Compare detailed vs non-detailed volume list endpoints
        - name: TEST17 - Get non-detailed volume list
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: volumes_basic

        - name: Get detailed volume list
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes/detail"
            method: GET
            return_content: true
          register: volumes_detailed

        - name: "ASSERT: Both endpoints return volume data"
          ansible.builtin.assert:
            that:
              - "volumes_basic is succeeded"
              - "volumes_detailed is succeeded"
              - "((volumes_basic.content | from_json).volumes | length) > 0"
              - "((volumes_detailed.content | from_json).volumes | length) > 0"

        # TEST18: List available flavors
        - name: TEST18 - List flavors (detailed)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/flavors/detail"
            method: GET
            return_content: true
          register: flavors_list

        - name: "ASSERT: Flavors endpoint returns data"
          ansible.builtin.assert:
            that:
              - "flavors_list is succeeded"
              - "((flavors_list.content | from_json).flavors | length) > 0"
              - "((flavors_list.content | from_json).flavors | selectattr('id', 'defined') | list | length) > 0"

        # TEST19: Authenticate and validate token format
        - name: TEST19 - Request authentication token
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/auth/tokens"
            method: POST
            body_format: json
            return_content: true
            body:
              auth:
                identity:
                  methods: ["password"]
                  password:
                    user:
                      name: "demo-user"
                      password: "password"
                      domain:
                        name: "default"
                scope:
                  project:
                    name: "demo"
                    domain:
                      name: "default"
            status_code: 201
          register: auth_token_test

        - name: "ASSERT: Token authentication successful"
          ansible.builtin.assert:
            that:
              - "auth_token_test is succeeded"
              - "auth_token_test.x_subject_token is defined"
              - "((auth_token_test.content | from_json).token.catalog | length) > 0"

        # TEST20: Various malformed JSON request formats
        - name: TEST20 - Send completely invalid JSON
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body: "this is not json at all"
            status_code: 400
          register: malformed_not_json
          failed_when: false

        - name: Send JSON with wrong structure
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: '{"wrong_key":"value"}'
            status_code: 400
          register: malformed_wrong_structure
          failed_when: false

        - name: Send empty JSON
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            body: "{}"
            status_code: 400
          register: malformed_empty
          failed_when: false

        - name: "ASSERT: Malformed requests rejected (mock has limited validation)"
          ansible.builtin.assert:
            that:
              - "malformed_not_json.status == 400"
              - "malformed_wrong_structure.status in [400, 202]"
              - "malformed_empty.status in [400, 202]"
            msg: "Mock accepts some invalid JSON - real OpenStack would return 400"

        # TEST21: Create 10 volumes sequentially (stress test - reduced to prevent crashes)
        - name: TEST21 - Create 10 volumes sequentially
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"stress-vol-{{ item }}","size":5}}'
            status_code: 202
          loop: "{{ range(1, 11) | list }}"
          register: stress_volumes

        - name: "ASSERT: All 10 volumes created"
          ansible.builtin.assert:
            that:
              - "stress_volumes.results | length == 10"
              - "stress_volumes.results | selectattr('failed', 'equalto', false) | list | length == 10"

        # TEST22: List 10+ volumes efficiently
        - name: TEST22 - List all volumes (10+ count)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: large_volume_list

        - name: "ASSERT: Large volume list returned"
          ansible.builtin.assert:
            that:
              - "large_volume_list is succeeded"
              - "((large_volume_list.content | from_json).volumes | length) >= 10"

        # TEST23: Attach 5 volumes to single server (multiple attachments)
        - name: Create server for multiple attachments
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "multi-attach-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: multi_attach_server

        - name: Create 5 volumes for attachment
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"multi-vol-{{ item }}","size":5}}'
            status_code: 202
          loop: "{{ range(1, 6) | list }}"
          register: multi_vols

        - name: TEST23 - Attach 5 volumes to single server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (multi_attach_server.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (item.content | from_json).volume.id }}"
            status_code: 200
          loop: "{{ multi_vols.results }}"
          register: multi_attachments

        - name: "ASSERT: All 5 volumes attached to single server"
          ansible.builtin.assert:
            that:
              - "multi_attachments.results | length == 5"
              - "multi_attachments.results | selectattr('failed', 'equalto', false) | list | length == 5"

        # TEST24: Create server with multiple networks
        - name: Create second network
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/networks"
            method: POST
            body_format: json
            return_content: true
            body:
              network:
                name: "test-network-24-a"
            status_code: 201
          register: network_24a

        - name: Create third network
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/networks"
            method: POST
            body_format: json
            return_content: true
            body:
              network:
                name: "test-network-24-b"
            status_code: 201
          register: network_24b

        - name: TEST24 - Create server with multiple networks
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "multi-network-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks:
                  - uuid: "{{ (network_24a.content | from_json).network.id }}"
                  - uuid: "{{ (network_24b.content | from_json).network.id }}"
            status_code: 202
          register: multi_network_server

        - name: "ASSERT: Server created with multiple networks"
          ansible.builtin.assert:
            that:
              - "multi_network_server is succeeded"
              - "((multi_network_server.content | from_json).server.addresses | length) == 2"

        # TEST25: Concurrent operations across resource types (volumes + servers)
        - name: TEST25 - Create volumes and servers concurrently
          ansible.builtin.uri:
            url: "{{ item.url }}"
            method: POST
            body_format: json
            return_content: true
            body: "{{ item.body }}"
            status_code: 202
          loop:
            - url: "{{ fake_os_url }}/v3/demo/volumes"
              body: '{"volume":{"name":"concurrent-mixed-vol-1","size":5}}'
            - url: "{{ fake_os_url }}/v2.1/demo/servers"
              body: '{"server":{"name":"concurrent-mixed-srv-1","flavorRef":"1","imageRef":"img-1","networks":[]}}'
            - url: "{{ fake_os_url }}/v3/demo/volumes"
              body: '{"volume":{"name":"concurrent-mixed-vol-2","size":10}}'
            - url: "{{ fake_os_url }}/v2.1/demo/servers"
              body: '{"server":{"name":"concurrent-mixed-srv-2","flavorRef":"2","imageRef":"img-1","networks":[]}}'
          async: 30
          poll: 0
          register: mixed_async

        - name: Wait for concurrent operations
          ansible.builtin.async_status:
            jid: "{{ item.ansible_job_id }}"
          loop: "{{ mixed_async.results }}"
          register: mixed_results
          until: mixed_results.finished
          retries: 10
          delay: 1

        - name: "ASSERT: All concurrent operations succeeded"
          ansible.builtin.assert:
            that:
              - "item is succeeded"
          loop: "{{ mixed_results.results }}"

        # TEST26: Sequential attachment of multiple volumes to same server
        - name: Create server for sequential attachments
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "sequential-attach-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: seq_server

        - name: Create volumes for sequential attachment
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"seq-vol-{{ item }}","size":5}}'
            status_code: 202
          loop: [1, 2, 3]
          register: seq_vols

        - name: TEST26 - Attach volumes sequentially
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (seq_server.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (item.content | from_json).volume.id }}"
            status_code: 200
          loop: "{{ seq_vols.results }}"
          register: seq_attachments

        - name: "ASSERT: Sequential attachments successful"
          ansible.builtin.assert:
            that:
              - "seq_attachments.results | length == 3"
              - "seq_attachments.results | selectattr('failed', 'equalto', false) | list | length == 3"

        # TEST27: Create two volumes with identical names (collision handling)
        - name: TEST27 - Create first volume with name
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"duplicate-name-test","size":5}}'
            status_code: 202
          register: dup_vol_1

        - name: Create second volume with same name
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"duplicate-name-test","size":5}}'
            status_code: 202
          register: dup_vol_2

        - name: "ASSERT: Mock allows duplicate names (different IDs)"
          ansible.builtin.assert:
            that:
              - "dup_vol_1 is succeeded"
              - "dup_vol_2 is succeeded"
              - "(dup_vol_1.content | from_json).volume.id != (dup_vol_2.content | from_json).volume.id"
            msg: "Mock doesn't prevent duplicate names - real OpenStack behavior may vary"

        # TEST28: Create volume with Unicode/UTF-8 name
        - name: TEST28 - Create volumes with Unicode characters
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"{{ item.name }}","size":5}}'
            status_code: 202
          loop:
            - { name: "volume-with-Ã©mojis-ðŸš€" }
            - { name: "volume-ä¸­æ–‡-name" }
            - { name: "volume-×¢×‘×¨×™×ª" }
          register: unicode_volumes
          failed_when: false

        - name: "ASSERT: Unicode names handled (some may fail)"
          ansible.builtin.assert:
            that:
              - "(unicode_volumes.results | selectattr('failed', 'equalto', false) | list | length) >= 2"
            msg: "Some Unicode characters may crash mock server"

        # TEST29: Cross-validate attachment state (volume.attachments + server list)
        - name: Create server for cross-validation
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "cross-val-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: cross_val_server

        - name: Create and attach volume
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"cross-val-volume","size":5}}'
            status_code: 202
          register: cross_val_vol

        - name: Attach volume
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (cross_val_server.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (cross_val_vol.content | from_json).volume.id }}"
            status_code: 200
          register: cross_val_attach

        - name: Get volume details
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: cross_val_volumes

        - name: Get server attachments
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (cross_val_server.content | from_json).server.id }}/os-volume_attachments"
            method: GET
            return_content: true
          register: cross_val_attachments

        - name: TEST29 - Cross-validate attachment from both sides
          ansible.builtin.assert:
            that:
              - >-
                (((cross_val_volumes.content | from_json).volumes |
                selectattr('id', 'equalto', (cross_val_vol.content | from_json).volume.id) |
                first).status) == 'in-use'
              - >-
                ((cross_val_attachments.content | from_json).volumeAttachments |
                selectattr('volumeId', 'equalto', (cross_val_vol.content | from_json).volume.id) |
                list | length) == 1

        # TEST30: Volume status persistence across multiple reads
        - name: Create volume for persistence test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"persistence-test","size":5}}'
            status_code: 202
          register: persist_vol

        - name: Read volume status (first time)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: persist_read_1

        - name: Read volume status (second time)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: persist_read_2

        - name: Read volume status (third time)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: GET
            return_content: true
          register: persist_read_3

        - name: Extract volume from all reads
          ansible.builtin.set_fact:
            persist_vol_id: "{{ (persist_vol.content | from_json).volume.id }}"
            vol_read_1: "{{ (persist_read_1.content | from_json).volumes | selectattr('id', 'equalto', (persist_vol.content | from_json).volume.id) | first }}"
            vol_read_2: "{{ (persist_read_2.content | from_json).volumes | selectattr('id', 'equalto', (persist_vol.content | from_json).volume.id) | first }}"
            vol_read_3: "{{ (persist_read_3.content | from_json).volumes | selectattr('id', 'equalto', (persist_vol.content | from_json).volume.id) | first }}"

        - name: TEST30 - Verify volume status persistence
          ansible.builtin.assert:
            that:
              - "vol_read_1.status == 'available'"
              - "vol_read_2.status == 'available'"
              - "vol_read_3.status == 'available'"
              - "vol_read_1.id == persist_vol_id"
              - "vol_read_2.id == persist_vol_id"
              - "vol_read_3.id == persist_vol_id"

        # TEST31: Attach network interface dynamically
        - name: Create server for interface attachment test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "interface-test-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: interface_server

        - name: Create port for dynamic attachment
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: POST
            body_format: json
            return_content: true
            body:
              port:
                network_id: "net-1"
            status_code: 201
          register: interface_port

        - name: TEST31 - Attach interface to server dynamically
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (interface_server.content | from_json).server.id }}/os-interface"
            method: POST
            body_format: json
            return_content: true
            body:
              interfaceAttachment:
                port_id: "{{ (interface_port.content | from_json).port.id }}"
            status_code: 200
          register: interface_attach

        - name: "ASSERT: Interface attached successfully"
          ansible.builtin.assert:
            that:
              - "interface_attach is succeeded"
              - "(interface_attach.content | from_json).interfaceAttachment is defined"
              - "(interface_attach.content | from_json).interfaceAttachment.port_id == (interface_port.content | from_json).port.id"
              - "(interface_attach.content | from_json).interfaceAttachment.server_id == (interface_server.content | from_json).server.id"

        - name: Detach interface from server
          ansible.builtin.uri:
            url: >-
              {{ fake_os_url }}/v2.1/demo/servers/{{
              (interface_server.content | from_json).server.id
              }}/os-interface/{{
              (interface_port.content | from_json).port.id
              }}
            method: DELETE
            status_code: 204

        - name: Get port details after detachment
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: GET
            return_content: true
          register: ports_after_detach

        - name: "ASSERT: Port detached and status changed to DOWN"
          ansible.builtin.assert:
            that:
              - >-
                ((ports_after_detach.content | from_json).ports |
                selectattr('id', 'equalto', (interface_port.content | from_json).port.id) |
                first).status == 'DOWN'
              - >-
                ((ports_after_detach.content | from_json).ports |
                selectattr('id', 'equalto', (interface_port.content | from_json).port.id) |
                first).device_id == None
            msg: "Port should be DOWN and device_id should be null after detachment"

        # TEST32: Server deletion cascade cleanup
        - name: Create server for deletion test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: POST
            body_format: json
            return_content: true
            body:
              server:
                name: "deletion-test-server"
                flavorRef: "1"
                imageRef: "img-1"
                networks: []
            status_code: 202
          register: deletion_server

        - name: Create volume for deletion test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v3/demo/volumes"
            method: POST
            body_format: json
            return_content: true
            body: '{"volume":{"name":"deletion-test-volume","size":5}}'
            status_code: 202
          register: deletion_volume

        - name: Attach volume to server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (deletion_server.content | from_json).server.id }}/os-volume_attachments"
            method: POST
            body_format: json
            return_content: true
            body:
              volumeAttachment:
                volumeId: "{{ (deletion_volume.content | from_json).volume.id }}"
            status_code: 200

        - name: Create port for deletion test
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: POST
            body_format: json
            return_content: true
            body:
              port:
                network_id: "net-1"
            status_code: 201
          register: deletion_port

        - name: Attach port to server
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (deletion_server.content | from_json).server.id }}/os-interface"
            method: POST
            body_format: json
            body:
              interfaceAttachment:
                port_id: "{{ (deletion_port.content | from_json).port.id }}"
            status_code: 200

        - name: TEST32 - Delete server with attached resources
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers/{{ (deletion_server.content | from_json).server.id }}"
            method: DELETE
            status_code: 204

        - name: Verify server deleted from list
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.1/demo/servers"
            method: GET
            return_content: true
          register: servers_after_delete

        - name: "ASSERT: Server removed from server list"
          ansible.builtin.assert:
            that:
              - "(deletion_server.content | from_json).server.id not in ((servers_after_delete.content | from_json).servers | map(attribute='id'))"

        # TODO: Add volume deletion tests in srv.go !!!
        # - name: Verify volume detached (status back to available)
        #   ansible.builtin.uri:
        #     url: "{{ fake_os_url }}/v3/demo/volumes"
        #     method: GET
        #     return_content: true
        #   register: volumes_after_delete

        # - name: "ASSERT: Volume status returned to available"
        #   ansible.builtin.assert:
        #     that:
        #       -#       - >-
        #         ((volumes_after_delete.content | from_json).volumes |
        #         selectattr('id', 'equalto', (deletion_volume.content | from_json).volume.id) |
        #         first).status == 'available'
        #       #       - >-
        #         ((volumes_after_delete.content | from_json).volumes |
        #         selectattr('id', 'equalto', (deletion_volume.content | from_json).volume.id) |
        #         first).attachments | length == 0
        #     msg: "Volume should be available with no attachments after server deletion"

        - name: Verify port released (device_id cleared)
          ansible.builtin.uri:
            url: "{{ fake_os_url }}/v2.0/ports"
            method: GET
            return_content: true
          register: ports_after_delete

        - name: "ASSERT: Port released from server"
          ansible.builtin.assert:
            that:
              - >-
                ((ports_after_delete.content | from_json).ports |
                selectattr('id', 'equalto', (deletion_port.content | from_json).port.id) |
                first).device_id == None
              - >-
                ((ports_after_delete.content | from_json).ports |
                selectattr('id', 'equalto', (deletion_port.content | from_json).port.id) |
                first).status == 'DOWN'
            msg: "Port should have null device_id and DOWN status after server deletion"

      # CLEANUP
      always:
        - name: Stop fake OpenStack server
          tags: cleanup
          ansible.builtin.command: "kill {{ fake_os_pid }}"
          changed_when: false
          failed_when: false

        - name: Remove PID file
          tags: cleanup
          ansible.builtin.file:
            path: "{{ server_pid_file }}"
            state: absent
          failed_when: false
# BLOCKED BY SRV.GO LIMITATIONS:
# These tests require srv.go extensions before implementation:
# - List volumes with filter by name (requires query parameter support)
# - List and create images (requires Glance endpoints beyond catalog)
# - Get network by ID (requires GET /v2.0/networks/{id} endpoint)
# - Attach volume to non-existent server (requires validation logic)
# - Attach non-existent volume (requires validation logic)
# - OpenStack CLI compatibility (requires proper Content-Type headers + field formatting)
#
# Additional blocked tests requiring srv.go state management:
# - Volume GET by ID endpoint (for state polling)
# - Volume DELETE endpoint (for cleanup validation)
# - Volume attachment DELETE endpoint (DELETE /os-volume_attachments/{id})
# - Stateful transitions (creating â†’ available, attaching â†’ in-use)
# - Error simulation (409 conflicts, timeouts, busy states)
